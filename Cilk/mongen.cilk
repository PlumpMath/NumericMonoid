// Compilation:
//    gcc -O3 -Wall -ggdb mgen.c -c && gcc mgen.o -o mgen
// Visualisation:
//    objdump -dS mgen.o
/*
Size = 1 2 4 7 12 23 39 67 118 204 343 592 1001 1693 2857 4806 8045 13467 22464 37396 62194 103246 170963 282828 467224 770832 1270267 2091030 3437839 5646773 9266788 15195070 24896206 40761087 66687201 109032500 178158289 290939807 474851445 774614284 

*/

#include <assert.h>
#include <stdio.h>
#include <x86intrin.h>

#ifdef CILK
#include <cilk-lib.cilkh>
#else
#define cilk
#define spawn
#define sync
#define Self (0)
#define SYNCHED (1)
#define Cilk_active_size (1)
#define Cilk_alloca (alloca)
#endif


typedef unsigned char epi8 __attribute__ ((vector_size (16)));
epi8 zero, block2, shift16[16], mask16[16];

#define nth_block(st, i) (((epi8 *) st)[i])
#define load_epi8(t) ((epi8) _mm_loadu_si128((__m128i *) (t)))
#define store_epi8(t, v) (_mm_store_si128((__m128i *) (t), (__m128i) (v)))
#define storeu_epi8(t, v) (_mm_storeu_si128((__m128i *) (t), (__m128i) (v)))

#define MAX_GENUS 40
#define SIZE_BOUND (3*(MAX_GENUS-1))
#define NBLOCKS ((SIZE_BOUND+15) >> 4)
#define SIZE (NBLOCKS << 4)


typedef unsigned char nb_decompositions[SIZE] __attribute__ ((aligned (16)));
typedef struct {
  nb_decompositions decs;
  unsigned long int conductor, min, genus;
} monoid;

typedef unsigned long long int result[MAX_GENUS];

result *numbers_proc_local;

void print_monoid(monoid *pm)
{
  unsigned int i;
  printf("min = %i, cond = %i, genus = %i, decs = ",
	 pm->min, pm->conductor, pm->genus);
  for (i=0; i<SIZE; i++) printf("%u ", pm->decs[i]);
  printf("\n");
}

void print_epi8(epi8 bl)
{
  unsigned int i;
  for (i=0; i<16; i++) printf("%u ", ((unsigned char*)&bl)[i]);
  printf("\n");
}

inline void remove_generator(monoid *__restrict__ src,
		      monoid *__restrict__ dst,
		      unsigned long int gen)
{
  unsigned long int start_block, decal, i;
  epi8 block;

  assert(src->decs[gen] == 2);

  dst->conductor = gen + 1;
  dst->genus = src->genus + 1;
  dst->min = gen == src->min ? dst->conductor : src->min;

  for (i=0; i<NBLOCKS; i++)
    nth_block(dst->decs, i) = nth_block(src->decs, i);

  start_block = gen >> 4;
  decal = gen & 0xF;
  // Shift block by decal uchar
  block = (epi8) _mm_shuffle_epi8((__m128i) nth_block(src->decs, 0),
				  (__m128i) shift16[decal]);
  nth_block(dst->decs, start_block) -= ((block != zero) & block2);

  for (i=start_block+1; i<NBLOCKS; i++)
    {
      // The following won't work due to a bug in GCC 4.7.1
      // block = *((epi8*)(src->decs + ((i-start_block)<<4) - decal));
      block = load_epi8(src->decs + ((i-start_block)<<4) - decal);
      nth_block(dst->decs, i) -= ((block != zero) & block2);
    }
  if (2*gen<SIZE) dst->decs[2*gen]++;

  assert(dst->decs[dst->conductor-1] == 0);
}


cilk void walk_children(monoid *pm)
{
  unsigned long int iblock, decal, shift, gen;
  monoid tmpmon, *newmonoid = &tmpmon;
  unsigned int mask, nbr;
  epi8 block;

  iblock = pm->conductor >> 4;
  decal = pm->conductor & 0xF;
  block = nth_block(pm->decs, iblock) & mask16[decal];
  mask  = _mm_movemask_epi8((__m128i) (block == block2));
  if (pm->genus < MAX_GENUS-1)
    {
      nbr = 0;
      do
	{
	  gen = (iblock << 4) - 1;
	  while (mask)
	    {
	      shift = __bsfd (mask) + 1;
	      gen += shift;
	      mask >>= shift;
	      if (!SYNCHED) // Another thread is still working on the former newmonoid
		newmonoid = (monoid *) Cilk_alloca(sizeof(monoid));
	      remove_generator(pm, newmonoid, gen);
	      spawn walk_children(newmonoid);
	      nbr++;
	    }
	  iblock++;
	  block = nth_block(pm->decs, iblock);
	  mask  = _mm_movemask_epi8((__m128i) (block == block2));
	}
      while (iblock <= (pm->conductor+pm->min+15) >> 4);
    }
  else
  {
    nbr = _mm_popcnt_u32(mask);
    for (iblock++; iblock <= (pm->conductor+pm->min+15) >> 4; iblock++)
      {
	block = nth_block(pm->decs, iblock);
	nbr += _mm_popcnt_u32(_mm_movemask_epi8((__m128i) (block == block2)));
      }
  }

  numbers_proc_local[Self][pm->genus]+=nbr;
}


void print_sizes(int nproc)
{
  int i, proc;

  printf("Size = ");
  for (i=0; i<MAX_GENUS; i++)
    {
      unsigned long long int res = 0;
      for (proc=0; proc<nproc; proc++) res += numbers_proc_local[proc][i];
      printf("%llu ", res);
    }
  printf("\n");
}



#include <signal.h>

#define PERIOD 5
int nproc, nloops=0;
void sigalrm_handler( int sig )
{
  printf("\nNloops = %i\n", nloops++);
  print_sizes(nproc);
  alarm(PERIOD);
}

void start_alarm(int np)
{
    struct sigaction sact;

    nproc = np;
    sigemptyset(&sact.sa_mask);
    sact.sa_flags = 0;
    sact.sa_handler = sigalrm_handler;
    sigaction(SIGALRM, &sact, NULL);

    alarm(PERIOD);
}


cilk int main(void)
{
  unsigned long int i, j;
  int proc;
  epi8 block;
  monoid N, N1;

  printf("Computing number of numeric monoids for genus <= %i\n", MAX_GENUS);
  start_alarm(Cilk_active_size);

  // Init the proc local results
  numbers_proc_local = (result *) malloc(Cilk_active_size*sizeof(result));
  for (proc=0; proc<Cilk_active_size; proc++)
    for (i=0; i<MAX_GENUS; i++) numbers_proc_local[proc][i] = 0;
  // Init the shifter
  for (i=0; i<16; i++) ((unsigned char *)&shift16[0])[i] = -1;
  mask16[0] = shift16[0];
  for (i=1; i<16; i++) shift16[i] = shift16[0];
  for (i=0; i<16; i++) for (j=i; j<16; j++) ((unsigned char *)&shift16[i])[j] = j-i;
  for (i=1; i<16; i++) {
    mask16[i] = mask16[i-1];
    ((unsigned char *)&mask16[i])[i-1] = 0;
  }
  // Various init
  for (i=0; i<16; i++) ((unsigned char *)&zero)[i] = 0;
  for (i=0; i<16; i++) ((unsigned char *)&block2)[i] = 2;
  // Init the monoid N
  for (i=0; i<16; i++) ((unsigned char *)&block)[i] = i+1;
  for (i=0; i<NBLOCKS; i++) nth_block(N.decs, i) = block + ((unsigned char) (i<<4));
  N.genus = 0;
  N.conductor = 1;
  N.min = 1;
  // N1 := N / 1
  remove_generator(&N, &N1, 1);
  numbers_proc_local[0][0] = 1;

  spawn walk_children(&N1);
  sync;

  printf("\n============================\n\n");
  print_sizes(Cilk_active_size);
  free(numbers_proc_local);
  return EXIT_SUCCESS;
}



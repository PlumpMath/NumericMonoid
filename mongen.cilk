// Compilation:
//    gcc -O3 -Wall -ggdb mgen.c -c && gcc mgen.o -o mgen
// Visualisation:
//    objdump -dS mgen.o
/*
Size = 1 2 4 7 12 23 39 67 118 204 343 592 1001 1693 2857 4806 8045 13467 22464 37396 62194 103246 170963 282828 467224 770832 1270267 2091030 3437839 5646773 9266788 15195070 24896206 40761087 66687201 109032500 178158289 290939807 474851445 774614284 

*/

#include <stdio.h>
#include <assert.h>

#ifndef C_ELISION
#include <cilk-lib.cilkh>
#endif

#include "alarm.h"
#include "monoid.h"

cilk void walk_children(monoid *pm)
{
  unsigned long int iblock, shift, gen;
  monoid tmpmon, *newmonoid = &tmpmon;
  unsigned int mask;
  epi8 block;

  iblock = pm->conductor >> 4;
  block = nth_block(pm->decs, iblock) & mask16[pm->conductor & 0xF];
  mask  = _mm_movemask_epi8((__m128i) (block == block2));
  if (pm->genus < MAX_GENUS-1)
    {
      unsigned long int nbr = 0;
      gen = (iblock << 4) - 1;
      do
	{
	  if (mask)
	    {
	      shift = __bsfd (mask) + 1;
	      gen += shift;
	      mask >>= shift;
	      if (!SYNCHED) // Another thread is still working on the former newmonoid
		newmonoid = (monoid *) Cilk_alloca(sizeof(monoid));
	      remove_generator(pm, newmonoid, gen);
	      spawn walk_children(newmonoid);
	      nbr++;
	    }
	  else
	    {
	      if (++iblock > (pm->conductor+pm->min+15) >> 4) break;
	      gen = (iblock << 4) - 1;
	      block = nth_block(pm->decs, iblock);
	      mask  = _mm_movemask_epi8((__m128i) (block == block2));
	    }
	}
      while (1);
      results_proc_local[Self][pm->genus]+=nbr;
    }
  else
  {
    unsigned char nbr = _mm_popcnt_u32(mask);
    for (iblock++; iblock <= (pm->conductor+pm->min+15) >> 4; iblock++)
      {
	block = nth_block(pm->decs, iblock);
	nbr += _mm_popcnt_u32(_mm_movemask_epi8((__m128i) (block == block2)));
      }
      results_proc_local[Self][pm->genus]+=nbr;
  }

}

int nproc;
void print_sizes()
{
  int i, proc;

  printf("Size = ");
  for (i=0; i<MAX_GENUS; i++)
    {
      unsigned long long int res = 0;
      for (proc=0; proc<nproc; proc++) res += results_proc_local[proc][i];
      printf("%llu ", res);
    }
  printf("\n");
}

void progress_report(void) { print_sizes(); }



cilk int main(void)
{
  unsigned long int i, j;
  int proc;
  epi8 block;
  monoid N, N1;

  printf("Computing number of numeric monoids for genus <= %i\n", MAX_GENUS);
  nproc = Cilk_active_size;
  start_alarm();

  // Init the proc local results
  results_proc_local = malloc(Cilk_active_size*sizeof(result));
  for (proc=0; proc<Cilk_active_size; proc++)
    for (i=0; i<MAX_GENUS; i++) results_proc_local[proc][i] = 0;
  // Init the shifter
  for (i=0; i<16; i++) ((unsigned char *)&shift16[0])[i] = -1;
  mask16[0] = shift16[0];
  for (i=1; i<16; i++) shift16[i] = shift16[0];
  for (i=0; i<16; i++) for (j=i; j<16; j++) ((unsigned char *)&shift16[i])[j] = j-i;
  for (i=1; i<16; i++) {
    mask16[i] = mask16[i-1];
    ((unsigned char *)&mask16[i])[i-1] = 0;
  }
  // Various init
  for (i=0; i<16; i++) ((unsigned char *)&zero)[i] = 0;
  for (i=0; i<16; i++) ((unsigned char *)&block2)[i] = 2;
  // Init the monoid N
  for (i=0; i<16; i++) ((unsigned char *)&block)[i] = i+1;
  for (i=0; i<NBLOCKS; i++) nth_block(N.decs, i) = block + ((unsigned char) (i<<4));
  N.genus = 0;
  N.conductor = 1;
  N.min = 1;
  // N1 := N / 1
  remove_generator(&N, &N1, 1);
  results_proc_local[0][0] = 1;

  spawn walk_children(&N1);
  sync;

  printf("\n============================\n\n");
  print_sizes();
  free(results_proc_local);
  return EXIT_SUCCESS;
}



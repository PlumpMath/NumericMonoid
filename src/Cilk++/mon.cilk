#include <alloca.h>
#include "monoid.h"
#include <reducer_opadd.h>
#include <iostream>

extern "C++"
{

class monoid_holder
{
  struct FakeReducer: cilk::monoid_base<monoid>
  {
    // reduce function does nothing
    static void reduce (monoid *left, monoid *right)
    { std::cout << "reduce !"<< std::endl;};

    static void identity(monoid * p)
    { std::cout << "identity !"<< std::endl;};

    static void destroy(monoid * p)
    { std::cout << "destroy !"<< std::endl;};
  };
 private:
  cilk::reducer<FakeReducer> imp_;

 public:
  monoid_holder() : imp_() {};

  monoid &get_value()
  {
    return imp_.view();
  }
};

};

const unsigned long int target_genus = 5;

cilk::reducer_opadd<unsigned long int> cilk_result[target_genus+1];


void walk_children(monoid &pm)
{
  generator_iter scan;
  monoid_holder newmonoid;

  init_children_generator_iter(&pm, &scan);

  if (pm.genus < target_genus - 10)
    {
      unsigned long int nbr = 0, gen;
      while ((gen = next_generator_iter(&pm, &scan)) != 0)
	{
	  remove_generator(&pm, &newmonoid.get_value(), gen);
	  cilk_spawn walk_children(newmonoid.get_value());
	  nbr++;
	}
      cilk_result[pm.genus] += nbr;
    }
  else
    cilk_result[pm.genus] += count_generator_iter(&pm, &scan);
}


int cilk_main(void)
{
  monoid N, N1;

  std::cout << "Computing number of numeric monoids for genus <= "
	    << target_genus << std::endl;
  init_full_N(&N);
  remove_generator(&N, &N1, 1);
  cilk_result[0]++;

  print_monoid(&N1);

  cilk_spawn walk_children(N1);
  cilk_sync;

  std::cout << std::endl << "============================" << std::endl << std::endl;
  for (unsigned int i=0; i<target_genus+1; i++)
    std::cout << cilk_result[i].get_value() << " ";
  std::cout << std::endl;
  return EXIT_SUCCESS;
}

